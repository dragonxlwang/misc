#!/bin/sh

# color
function yellowecho { echo -e "\033[1;33m${1}\033[0m" }
function blueecho { echo -e "\033[1;36m${1}\033[0m" }
function redecho { echo -e "\033[1;31m${1}\033[0m" }
ANSI_COLOR_RED="\033[31m"   # \e vs \033
ANSI_COLOR_RESET="\033[0m"

# boost library
export BOOST_ROOT="${HOME}/local/boost"
LD_LIBRARY_PATH+=":${HOME}/local/boost:${HOME}/local/boost/lib:/usr/local/lib"
export LD_LIBRARY_PATH
export PATH=${PATH}:${HOME}/local

function work { tmux new -AD -s $(hostname -s)-main }

## ls -A: List all entries except for . and ...
## zsh f expansion flag to split on newline: arr_of_lns=("${(@f)$(my_cmd)}")
## @: In double quotes, array elements are put into separate words.
##    E.g., ‘"${(@)foo}"’ is equivalent to ‘"${foo[@]}"’ and ‘"${(@)foo[1,2]}"’
##    is the same as ‘"$foo[1]" "$foo[2]"’.
##    This is distinct from field splitting by the f, s or z flags, which still
##    applies within each array element.
## unix.stackexchange.com/questions/28854/list-elements-with-spaces-in-zsh
alias dir_size='for f in "${(@f)$(ls -A)}"; do du -sh $f; done;'

## show history with time, increase history size
## https://github.com/robbyrussell/oh-my-zsh/issues/739
## ./.oh-my-zsh/lib/history.zsh
## "mm/dd/yyyy":  -f
## "dd.mm.yyyy":  -E
## "yyyy-mm-dd":  -i
## HISTSIZE is the maximum number of lines that are kept in a session and
## SAVEHIST is the maximum number of lines that are kept in the history file.
alias history='fc -i -l 1'

alias rrm='/bin/rm -v'
function rm {
  local ret=""
  ret=$(mv --verbose -f --backup=numbered \
        --target-directory ${HOME}/.trash/ "$@")
  echo -e $ANSI_COLOR_RED$ret$ANSI_COLOR_RESET
  local reg=""
  local f1=""
  local f2=""
  local fp="${HOME}/.trash/rm.undo"
  echo "#!/bin/sh" > $fp
  for l in ${(f)ret}; do
    reg='s/^(.*) -> (.*)$/\1/p'
    f1=$(echo $l | sed -rn $reg)
    f1=${f1:1:${#f1}-2}
    reg='s/^(.*) -> (.*)$/\2/p'
    f2=$(echo $l | sed -rn $reg)
    f2=$(echo $f2 | sed -r 's/ \(backup: .*\)//')
    f2=${f2:1:${#f2}-2}
    [[ $f1 != /* ]] && f1="$PWD/$f1"
    echo "# \"$f1\" -> \"$f2\"" >> $fp
    echo "mv \"$f2\" \"$f1\"" >> $fp
    echo "echo \"\\033[1;33mmv \\\"$f2\\\" \\\"$f1\\\"\\033[0m\"" >> $fp
  done
}
function undo {
  local fp="${HOME}/.trash/rm.undo"
  /bin/sh $fp
}
alias empty_trash='/bin/rm -rf --verbose  ~/.trash/*'
alias cls='printf "\033c"'
alias eliot="ssh -X eliot.cs.illinois.edu"
alias run_matlab="matlab -nodesktop -nosplash -r"
alias ed_profile="vim ~/.profile_wangxl; source ~/.profile_wangxl"
alias up_profile="source ~/.profile_wangxl; tmux source-file ~/.tmux.conf"
alias ed_tmux="vim ~/.tmux.conf; tmux source-file ~/.tmux.conf"
alias echo_path='echo ${PATH//:/"\n"}'
function reload_settings {
  echo "reloading ${HOME}/.profile_wangxl"
  source ${HOME}/.profile_wangxl
  echo "reloading ${HOME}/.tmux.conf"
  tmux source-file ${HOME}/.tmux.conf
}
alias ll="ls -alh"
function ll_symlink {
    [[ $# -eq 1 ]] && { ll $1 | grep "\->"} || {ll | grep "\->"} }
function kill_jobs { for i in $(seq 1 $(jobs | wc -l)); do kill %$i; done }
function jump { if [[ $# -eq 1 ]]; then cd $1; fi; cd $(pwd -P); }
alias jp="jump"

# zsh
if [[ $options[extended_glob] == off ]]; then setopt extended_glob; fi

# git
alias xg_log='git --no-pager log --pretty=format:"%h - %an, %ar : %s"'
function xg_sl {
  local option=""
  # by default, zsh does not split word
  # three ways to enable spliting safely
  # ${=a}
  # ${(@s: :)a} ## retain empty strings with @
  # eval "(${a})"
  if [[ $# -eq 0 ]]; then option="-10"; else eval "option=(${@})"; fi
  # replace -10 with --all
  git --no-pager log $option --branches --graph --decorate
}
function xg_sl_outgoing {
  git fetch
  git --no-pager log --branches --decorate --graph origin/master.. $@
}
function xg_sl_incoming {
  git fetch
  git --no-pager log --branches --decorate --graph ..origin/master $@
}
alias xg_ls='git ls-files'
alias xg_st='git status'
function xg_rm_last_commit {
  local ans=""
  echo -ne "${ANSI_COLOR_RED}Delete Last Commit [Y/N]?${ANSI_COLOR_RESET} "
  read ans
  ans=$(echo ${ans} | tr "[:upper:]" "[:lower:]")
  if [[ $ans == yes || $ans == y ]]; then
    yellowecho "deleting..."
    git reset --hard "HEAD^"
  else
    yellowecho "do nothing, exit..."
  fi
}
alias xg_rk_last_commit='git reset --soft "HEAD^"'
alias xg_browse='hub browse'
alias xg_list_remote_repo_branch='git ls-remote origin'
alias xg_show_remote_repo='git remote show origin'
alias xg_dry_run_featch='git fetch --dry-run'
function xg_check_remote_up_2_date {
  if [[ -z $(git fetch --dry-run 3>&2 2>&1 1>&3) ]]
  then
    blueecho "Git: up to date"
  else
    redecho "Git: need update"
  fi
}
alias xg_diff="git diff HEAD"
alias xg_ca="git commit -v -a --amend --no-edit"


#########################
# Mac Specific Settings #
#########################

# Homebrew permission problem
## sudo chown $(whoami):admin /usr/local \
##  && sudo chown -R $(whoami):admin /usr/local
## brew install coreutils
export HOMEBREW_GITHUB_API_TOKEN=2f9b5d70c1d10d2238d2b4846efb68a111524122

# To activate these completions, add the following to your .zshrc:
fpath=(/usr/local/share/zsh-completions $fpath)
#You may also need to force rebuild `zcompdump`:
#
#  rm -f ~/.zcompdump; compinit
#
#Additionally, if you receive "zsh compinit: insecure directories" warnings when attempting
#to load these completions, you may need to run this:
#
#  chmod go-w /usr/local/share


#source /usr/local/etc/bash_completion.d/password-store

# atom
function atom_overwrite_starred_package_list {
  apm starred --json > starred.json;
  js='fs = require("fs");'
  js+='JSON.parse(fs.readFileSync("starred.json")).forEach'
  js+='(function(item){ console.log(item.name); })'
  node -e  $js > starred.list;
  apm unstar `cat starred.list`;
  apm star --installed;
  /bin/rm starred.json starred.list;
}
function atom_install_starred_incremental {
  apm starred --json > starred.json;
  js='fs = require("fs");'
  js+='JSON.parse(fs.readFileSync("starred.json")).forEach'
  js+='(function(item){ console.log(item.name); })'
  node -e  $js > starred.list;
  apm list --installed --bare > installed.list
  for p in $(cat starred.list);
  do
    q=$(cat installed.list | grep "^$p@")
    if [[ -n $q ]];
    then
      blueecho "$q already installed. skipping..."
    else
      apm install $p
    fi
  done
  /bin/rm starred.json starred.list installed.list
}
function atom_ls_starred_packages {
  apm starred --json > starred.json;
  js='fs = require("fs");'
  js+='JSON.parse(fs.readFileSync("starred.json")).forEach'
  js+='(function(item){ console.log(item.name); })'
  node -e  $js;
  /bin/rm starred.json
}
function atom_ls_installed_packages {
  local ret=""
  ret=$(apm list --installed --bare)
  if [[ $1 == '--no-version' || $1 == '-n' ]]; then
    for f in $(echo $ret); do
      echo $f | sed -r 's/@.*//'
    done
  else
    echo $ret
  fi
}
function atom_install_from_list { apm install  $( cat ${1} ) }
alias atom_star_installed='apm star --installed'
alias atom_install_starred='apm stars --install'
alias atom_ls_starred='apm stars'
function atom_compare_packages {
  cd ${HOME}/.atom
  atom_ls_installed_packages -n > installed.list
  atom_ls_starred_packages > starred.list
  vimdiff *.list
}

# ipython
alias start_ipython='cd ${HOME}/Dropbox/workspace/ipython; jupyter notebook'

# mac show hidden files
# defaults write com.apple.finder AppleShowAllFiles YES

# open chrome with url/file
function go_url {
  "${HOME}/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" -app=$1
}
function go_file {
  go_url file:///$(readlink -f $1)
}
function go_chrome {
  "${HOME}/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" $1
}

# remove all .DS_store files in current directory recursively
function rm_finder_hidden_files {
  find . -name '*.DS_Store'  -type f -delete -print
  find . -name '*.localized' -type f -delete -print
}

# convert .mov to .gif annimation files
function convert_mov_to_gif {
  if [[ $(echo $1 | tr "[:upper:]" "[:lower:]") == *.mov ]]; then
    local f=$(echo $1 | sed 's/mov$/gif/i')
    ffmpeg -i $1 -vf "scale=min(iw\,600):-1" -pix_fmt rgb24 -r 10 -f gif - |\
    # convert -delay 5 -layers Optimize -loop 0 - $f
    gifsicle --optimize=3 --delay=7 > $f
    if [[ $2 == --publish ||  $2 == -p ]]; then
      local f0="${HOME}/Dropbox/Public"
      local home_url=$(cat "${HOME}/Dropbox/Public/home_url")
      local f1=/$(basename $f)
      if [[ $3 == --date || $3 == -d ]]; then
        f1="/screenshots/Screencast-"
        f1+=`date +"%Y.%m.%d-%H.%M"`.gif
      fi
      mv $f "$f0$f1"
      yellowecho "converted gif file: $f0$f1"
      yellowecho "public url is: $home_url$f1"
    fi
  else
    echo "$1 is not a .mov file"
  fi
}

# markdown
function markdown {
    local f=$(echo $1 | sed 's/\(md\|markdown\)$/htm/i')
    /usr/local/bin/markdown --html4tags $1 > $f
}

# update homebrew, oh-my-zsh, pip and source profile again
function update_scripts {
  upgrade_oh_my_zsh
  yellowecho "brew update"
  brew update
  yellowecho "brew upgrade"
  brew upgrade
  yellowecho "brew cask update"
  brew cask update
  yellowecho "brew cask cleanup"
  brew cask cleanup
  yellowecho "brew cleanup"
  brew cleanup
  yellowecho "pip install --upgrade pip"
  pip install --upgrade pip
  # yellowecho "pip update package"
  # pip freeze --local | grep -v '^\-e' | cut -d = -f 1  |\
  # xargs -n1 pip install -U
  yellowecho "source profile_wangxl"
  source ${HOME}/.profile_wangxl
  yellowecho "source tmux conf"
  tmux source ${HOME}/.tmux.conf
}

function lt {
  if [[ -z "$TMUX" ]]
    then
    local option=""
    while true
    do
      echo "Following starting options are available:"
      yellowecho "  (1)	:   ssh timan101"
      yellowecho "  (2)	:   ssh timan102"
      yellowecho "  (3)	:   ssh timan103"
      yellowecho "  (4/t)	:   tmux new -AD -s $(hostname -s)-main"
      yellowecho "  (5/n)	:   zsh"
      echo $(printf '=%.0s' {1..50})
      echo -n "Select One Option From (1) - (5): "
      if [[ $# -eq 1 ]]; then echo $1; option=$1; else read option; fi
      if [[ $option == 1* ]]; then
        echo "  (1)	:   ssh timan101"
        option=1
        break
      elif [[ $option == 2* ]]; then
        echo "  (2)	:   ssh timan102"
        option=2
        break
      elif [[ $option == 3* ]]; then
        echo "  (3)	:   ssh timan103"
        option=3
        break
      elif [[ $option == 4* || $option == t* ]];  then
        echo "  (4)	:   tmux new -AD -s $(hostname -s)-main"
        option=4
        break
      elif [[ $option == 5* || $option == n* ]];  then
        echo "  (5)	:   zsh"
        option=5
        break
      else
        redecho "  Input Not Recognized..."
      fi
    done
    [[ $option -eq 1 ]] && ssh timan101
    [[ $option -eq 2 ]] && ssh timan102
    [[ $option -eq 3 ]] && ssh timan103
    [[ $option -eq 4 ]] && { tmux new -AD -s $(hostname -s)-main }
  fi
}

[[ -t 1 ]] && lt
